// Generated by CoffeeScript 1.3.1
(function() {
  var ReParse,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  exports.ReParse = ReParse = (function() {

    ReParse.name = 'ReParse';

    function ReParse() {
      this.chainl1 = __bind(this.chainl1, this);

      this.chainl = __bind(this.chainl, this);

      this.sepEndBy1 = __bind(this.sepEndBy1, this);

      this.sepEndBy = __bind(this.sepEndBy, this);

      this.endBy1 = __bind(this.endBy1, this);

      this.endBy = __bind(this.endBy, this);

      this.sepBy1 = __bind(this.sepBy1, this);

      this.sepBy = __bind(this.sepBy, this);

      this.many1 = __bind(this.many1, this);

      this.many = __bind(this.many, this);

      this.skipWS = __bind(this.skipWS, this);

      this.skip1 = __bind(this.skip1, this);

      this.skip = __bind(this.skip, this);

      this.seq = __bind(this.seq, this);

      this.choice = __bind(this.choice, this);

      this.between = __bind(this.between, this);

      this.option = __bind(this.option, this);

      this.maybe = __bind(this.maybe, this);

      this.match = __bind(this.match, this);

      this.start = __bind(this.start, this);

      this.produce = __bind(this.produce, this);

      this.fail = __bind(this.fail, this);

      this.eof = __bind(this.eof, this);

      this.parse = __bind(this.parse, this);

    }

    ReParse.prototype.ignorews = false;

    ReParse.prototype.parse = function(input) {
      return this.input = input;
    };

    ReParse.prototype.eof = function() {
      return this.input === "";
    };

    ReParse.prototype.fail = function(input) {
      if (input !== undefined) {
        this.input = input;
      }
      throw this.fail;
    };

    ReParse.prototype.produce = function(method) {
      var val;
      val = method instanceof RegExp ? this.match(method) : method.call(this);
      if (this.ignorews) {
        this.skipWS();
      }
      return val;
    };

    ReParse.prototype.start = function(method) {
      var val;
      val = void 0;
      this.ignorews && this.skipWS();
      try {
        val = this.produce(method);
        if (this.eof()) {
          return val;
        }
      } catch (err) {
        if (err !== this.fail) {
          throw err;
        }
      }
      throw new Error("Could not parse '" + this.input + "'.");
    };

    ReParse.prototype.match = function(pattern, putback) {
      var probe;
      if (putback == null) {
        putback = false;
      }
      probe = this.input.match(pattern);
      if (!probe) {
        return this.fail();
      }
      this.input = this.input.substr(((probe[1] != null) && putback ? probe[1].length : probe[0].length));
      if (probe[1] != null) {
        return probe[1];
      } else {
        return probe[0];
      }
    };

    ReParse.prototype.maybe = function(method) {
      var input;
      input = this.input;
      try {
        return this.produce(method);
      } catch (err) {
        if (err !== this.fail) {
          throw err;
        }
      }
      return this.fail(input);
    };

    ReParse.prototype.option = function(method, otherwise) {
      try {
        return this.maybe(method);
      } catch (err) {
        if (err !== this.fail) {
          throw err;
        }
      }
      return otherwise;
    };

    ReParse.prototype.between = function(left, right, body) {
      var input, val;
      input = this.input;
      val = void 0;
      try {
        this.produce(left);
        val = this.produce(body);
        this.produce(right);
        return val;
      } catch (err) {
        if (err !== this.fail) {
          throw err;
        }
      }
      return this.fail(input);
    };

    ReParse.prototype.choice = function() {
      var arg, input, _i, _len;
      input = this.input;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        arg = arguments[_i];
        try {
          return this.produce(arg);
        } catch (err) {
          if (err !== this.fail) {
            throw err;
          }
        }
      }
      return this.fail(input);
    };

    ReParse.prototype.seq = function() {
      var arg, input;
      input = this.input;
      try {
        return (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arguments.length; _i < _len; _i++) {
            arg = arguments[_i];
            _results.push(this.produce(arg));
          }
          return _results;
        }).apply(this, arguments);
      } catch (err) {
        if (err !== this.fail) {
          throw err;
        }
      }
      return this.fail(input);
    };

    ReParse.prototype.skip = function(method, min) {
      var found, input;
      if (min == null) {
        min = null;
      }
      found = 0;
      input = this.input;
      while (!this.eof()) {
        try {
          this.maybe(method);
          found++;
        } catch (err) {
          if (err !== this.fail) {
            throw err;
          }
          break;
        }
      }
      if (min && (found < min)) {
        return this.fail(input);
      } else {
        return this;
      }
    };

    ReParse.prototype.skip1 = function(method) {
      return this.skip(method, 1);
    };

    ReParse.prototype.skipWS = function() {
      this.match(/^\s*/);
      return this;
    };

    ReParse.prototype.many = function(method, min) {
      var input, result;
      if (min == null) {
        min = null;
      }
      input = this.input;
      result = [];
      while (!this.eof()) {
        try {
          result.push(this.maybe(method));
        } catch (err) {
          if (err !== this.fail) {
            throw err;
          }
        }
        break;
      }
      if (min && (result.length < min)) {
        return this.fail(input);
      } else {
        return result;
      }
    };

    ReParse.prototype.many1 = function(method) {
      return this.many(method, 1);
    };

    ReParse.prototype.sepBy = function(method, sep, min) {
      var input, orig, result;
      if (min == null) {
        min = 0;
      }
      orig = this.input;
      input = void 0;
      result = [];
      try {
        result.push(this.produce(method));
        while (!this.eof()) {
          try {
            input = this.input;
            this.produce(sep);
            result.push(this.produce(method));
          } catch (err) {
            if (err !== this.fail) {
              throw err;
            }
            this.fail(input);
          }
        }
      } catch (err) {
        if (err !== this.fail) {
          throw err;
        }
      }
      if (min && (result.length < min)) {
        return this.fail(orig);
      } else {
        return result;
      }
    };

    ReParse.prototype.sepBy1 = function(method, sep) {
      return this.sepBy(method, sep, 1);
    };

    ReParse.prototype.endBy = function(method, end, min) {
      var val;
      if (min == null) {
        min = 0;
      }
      val = this.many(method, min);
      this.produce(end);
      return val;
    };

    ReParse.prototype.endBy1 = function(method, end) {
      return this.endBy(method, end, 1);
    };

    ReParse.prototype.sepEndBy = function(method, sep, min) {
      var val;
      if (min == null) {
        min = 0;
      }
      val = this.sepBy(method, sep, min);
      this.option(sep);
      return val;
    };

    ReParse.prototype.sepEndBy1 = function(method, sep) {
      return this.sepEndBy(method, sep, 1);
    };

    ReParse.prototype.chainl = function(method, op, otherwise, min) {
      var found, input, orig, result;
      if (otherwise == null) {
        otherwise = null;
      }
      if (min == null) {
        min = null;
      }
      found = 0;
      result = otherwise;
      orig = this.input;
      input = void 0;
      try {
        result = this.maybe(method);
        found++;
        while (!this.eof()) {
          try {
            input = this.input;
            result = this.produce(op)(result, this.produce(method));
            found++;
          } catch (err) {
            if (err !== this.fail) {
              throw err;
            }
            this.fail(input);
          }
        }
      } catch (err) {
        if (err !== this.fail) {
          throw err;
        }
      }
      if (min && (found < min)) {
        return this.fail(input);
      } else {
        return result;
      }
    };

    ReParse.prototype.chainl1 = function(method, op) {
      return this.chainl(method, op, null, 1);
    };

    return ReParse;

  })();

}).call(this);
